package core.streams.deep;

import java.time.Instant;
import java.time.LocalDate;
import java.util.Arrays;
import java.util.IntSummaryStatistics;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;

public class StreamDemo {

	static List<String> prices = List.of("10.5", "20.75", "15.0");
	static List<Integer> nums = Arrays.asList(1, 3, 5, 3, 4, 8, 6, 9, 10, 22, 25, 23);
	static List<String> names = Arrays.asList("Fatima", "Arham", "Hapheej", "Rafeek");
	static List<Person> people = Arrays.asList(
		    new Person("Arham", "Narsinghpur", 2200, Arrays.asList("Reading", "Cricket")),
		    new Person("Fatime", "Narsinghpur", 2300, Arrays.asList("Swimming", "Chess")),
		    new Person("Hapheej", "Harrai", 1800, Arrays.asList("Reading", "Football"))
		);
	
	static List<Student> students = List.of(
		    new Student("Arham", List.of("Math", "Physics")),
		    new Student("Fatima", List.of("Physics", "Chemistry")),
		    new Student("Hafeej", List.of("Biology", "Math"))
		);
	
	
	public static void main(String[] args) {

// 1. Creation / Static Factory Methods
		
		Stream.of("Arham"); // Returns a sequential Stream containing a single element
		
		/* Returns sequential ordered stream whose elements are the specified values */
		
		boolean matched = Stream.of("Fatima", "Arham", "Hapheej", "Rafeek")
				.anyMatch(name->name.length()>1);
		System.out.println("All having length>0: "+matched);
		
		
		Stream.empty(); // Returns an empty sequential Stream
		
		/* Stream.generate -> It creates infinite sequential stream where each element is 
		 * generated by a Supplier, can limit it */
		Stream<Double> num = Stream.generate(Math::random).limit(2);
		num.forEach(System.out::println);
		
		Stream<String> hello = Stream.generate(() -> "Hello").limit(3);
		hello.forEach(System.out::println);
		
		/* Custom object generation */
		AtomicInteger id = new AtomicInteger(1);
		Stream<String> userIds = Stream.generate(() -> "User-" + id.getAndIncrement()).limit(2);
		userIds.forEach(System.out::println);
		
		/* Generate current timestamps */
		Stream<String> timestamps = Stream.generate(() -> Instant.now().toString()).limit(3);
		timestamps.forEach(System.out::println);
		
		Random random = new Random();
		Stream<Integer> num1 = Stream.generate(() -> random.nextInt(100)).limit(2);
		num1.forEach(System.out::println);
		
		
		/* Stream.iterate(T seed, UnaryOperator<T>)- starts with initial value and applying 
		 * function repeatedly to produce the next elements */
		
		Stream.iterate(1, n -> n + 1).limit(10).forEach(System.out::print);
		System.out.println();
		
		// Generate powers of 2
		Stream.iterate(1, n -> n * 2).limit(10).forEach(System.out::print);
		System.out.println();
		
		// Dates - Add 1 day repeatedly
		Stream.iterate(LocalDate.now(), date -> date.plusDays(1)).limit(3)
			.forEach(System.out::println);
		System.out.println();
		
		// Generate even numbers
		Stream.iterate(0, n -> n + 2).limit(10).forEach(System.out::print);
		System.out.println();
		
		
		/* Stream.iterate(T seed, Predicate<T>, UnaryOperator<T>)   // since Java 9 
		 * It provides bounded version without limit() */
		
		Stream.iterate(1, n -> n <= 10, n -> n + 1).forEach(System.out::print);
		System.out.println();
		
		// Print characters A to Z
		Stream.iterate('A', p -> p <= 'Z', n -> (char)(n + 1))
	      .forEach(System.out::print);
		System.out.println();
		
		List<String> list1 = List.of("A", "B", "C");
		List<String> list2 = List.of("X", "Y", "Z");
		
		/* Stream.concat- Merge two lists */
		
		Stream<String> combined = Stream.concat(list1.stream(), list2.stream());
		combined.forEach(System.out::print);
		
		
		
// 2. Intermediate Operations- These return a new stream and are lazy
		
		/* filter(Predicate<? super T> predicate)-	Filters elements by condition */
		
		nums.stream().filter(n -> n>5).collect(Collectors.toList());
		
		/* map(Function<? super T, ? extends R> mapper)-	Transforms each element
		 * String → Integer, Object → Field, lowercase → uppercase, User → user.name */
		
		List<String> name = people.stream().map(p->p.getName()).collect(Collectors.toList());
		name.forEach(System.out::print);
		System.out.println();
		
		/* mapToInt(ToIntFunction<? super T>)-	Transforms elements to IntStream
		 * Avoid boxing/unboxing, sum(), average(), uses IntStream internally  */
		
		names.stream().mapToInt(String::length).forEach(System.out::print);
		System.out.println();
		
		IntSummaryStatistics stats = names.stream().mapToInt(String::length).summaryStatistics();
		System.out.println("getSum: "+stats.getSum());
		
		/* mapToDouble(ToDoubleFunction<? super T>)- To DoubleStream */
		
		//prices.stream().mapToDouble(Double::parseDouble).summaryStatistics();
		
		double sum = prices.stream().mapToDouble(Double::parseDouble).sum();
		System.out.println("sum: "+sum);
		
		/* flatMap(Function<? super T, ? extends Stream<? extends R>>)
		 * transforms each element into a stream, then flattens all streams into a single stream */
		
		// Students → Courses → One flat stream of all unique course names
		
		Set<String> course = students.stream()
				.flatMap(s->s.getCourses().stream()).collect(Collectors.toSet());
		System.out.println(course);
		
		//students.stream().flatMap(s->s.getCourses().stream()).distinct().sorted()
			//.collect(Collectors.toList());
		
		/* s.getCourses().stream() → converts each student's course list into a Stream<String>
		 * flatMap(...) → merges all course streams into a single flat stream */
		
		List<String> lines = List.of("Java is fun", "Streams are powerful");
		
		List<String> words = lines.stream().flatMap(line -> Arrays.stream(line.split(" ")))
				.collect(Collectors.toList());
		System.out.println(words);
		
		List<List<Integer>> listOfLists = List.of(
			    List.of(1, 2, 3),
			    List.of(4, 5),
			    List.of(6, 7, 8)
			);
		
		List<Integer> flat = listOfLists.stream().flatMap(List::stream)
			    .collect(Collectors.toList());
		System.out.println(flat);
		
		/* flatMapToInt(...), flatMapToLong(...), flatMapToDouble(...)
		 * FlatMap to primitive streams */
		
		List<String> words1 = List.of("Hi", "OK");

		IntStream asciiStream = words1.stream()
		    .flatMapToInt(word -> word.chars()); // String.chars() returns IntStream

		asciiStream.forEach(n -> System.out.print(n+", "));
		System.out.println();
		
		List<Record> records = List.of(
			    new Record(1000L, 2000L),
			    new Record(3000L, 4000L)
			);
		
		LongStream longStream = records.stream().flatMapToLong(r -> Arrays.stream(r.timestamps));
		longStream.forEach(r-> System.out.print(r+", "));
		System.out.println();
		
		List<Product> products = List.of(
			    new Product(10.5, 12.0),
			    new Product(15.5, 18.0)
			);

		DoubleStream allPrices = products.stream()
				.flatMapToDouble(p -> Arrays.stream(p.priceHistory));
		allPrices.forEach(p-> System.out.print(p+", "));
		System.out.println();
		
		/* distinct()- Removes duplicates (based on equals) */
		
		List<Integer> unique= nums.stream().distinct().collect(Collectors.toList());
		System.out.println(unique);
		
		/* sorted()- Natural order sort */
		
		List<Integer> sorted= nums.stream().distinct().sorted().collect(Collectors.toList());
		System.out.println(sorted);
		
		/* sorted(Comparator<? super T>)- Custom order sort */
		
		sorted= nums.stream().distinct().sorted((x, y) -> y-x).collect(Collectors.toList());
		System.out.println(sorted);
		
		/* peek(Consumer<? super T>)- Consumes value, Debugging/logging */
		
		nums.stream().sorted().peek(n->System.out.print(n+", ")).collect(Collectors.toList());
		System.out.println();
		
		/* limit(long maxSize)-	Limits to N elements */
		
		sorted= nums.stream().limit(5).distinct().sorted((x, y) -> y-x).collect(Collectors.toList());
		System.out.println(sorted);
		
		/* skip(long n)-	Skips N elements */
		
		sorted= nums.stream().skip(5).distinct().sorted((x, y) -> y-x).collect(Collectors.toList());
		System.out.println(sorted);
		
		
		/* takeWhile(Predicate<? super T>)- Takes elements until predicate fails. (Java 9+)
		 * Take values from start while condition is true, and then stop
		 * Short-circuiting: Stops processing at first false
		 * Not the same as filter(), which checks every element */
		
		List<Integer> numbers = List.of(2, 4, 6, 9, 12, 5, 8);

		List<Integer> result = numbers.stream().takeWhile(n -> n < 10)
				.collect(Collectors.toList());
		System.out.println("takeWhile: "+result);
		
		// filter() checks all elements
		result = numbers.stream().filter(n -> n < 10).collect(Collectors.toList());
		System.out.println("filter: "+result);
		
		List<String> line = List.of("INFO: Starting app", "INFO: Loading", 
				"ERROR: Crash", "INFO: Recovered", "DEBUG: retry");

		List<String> beforeError = line.stream().takeWhile(lin -> !lin.startsWith("ERROR"))
		    .collect(Collectors.toList());
		System.out.println(beforeError);
		
		
		/* dropWhile(Predicate<? super T>)- Skips elements while predicate is true. (Java 9+)
		 * It skips (drops) elements from start of stream as long as predicate is true
		 * Once the predicate becomes false for first time, it starts including all remaining 
		 * elements (even if predicate becomes true again) */
		
		/* Drop from beginning while condition is true, then take everything after
		 * Operates only on ordered streams
		 * Does not re-check later elements
		 * Short-circuits at the first false and continues with the rest */
		
		result = numbers.stream().dropWhile(n -> n < 10).collect(Collectors.toList());
		System.out.println("dropWhile: "+result);
		
		beforeError = line.stream().dropWhile(lin -> !lin.startsWith("ERROR"))
			    .collect(Collectors.toList());
		System.out.println(beforeError);
		
		
		// Combine both takeWhile & dropWhile
		
		result = nums.stream().sorted().dropWhile(n -> n > 23).takeWhile(n -> n < 25)
				.collect(Collectors.toList());
		System.out.println(result);
		
		
		
// 3. Terminal Operations- These consume the stream and produce a result or side-effect
	}
}
